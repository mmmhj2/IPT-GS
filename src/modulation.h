#include <ros/ros.h>#include <SDL2/SDL.h>#include <string>#include "ColorSpaceCvt.h"namespace modulation{	SDL_Surface * mask;	bool isLoad = false;		// Check if the mask file is in correct format	// 0x7F : Gray	// 0xFF : White	// 0x00 : Black	void MaskSanityCheck()	{		if(mask->format->format != SDL_PIXELFORMAT_INDEX8)		{			ROS_ERROR("Wrong pixel format, expect %s, got %s", 				SDL_GetPixelFormatName(SDL_PIXELFORMAT_INDEX8), 				SDL_GetPixelFormatName(mask->format->format));				return;		}				SDL_Color white, black, gray;		white = mask->format->palette->colors[0xFF];		black = mask->format->palette->colors[0x00];		gray = mask->format->palette->colors[0x7F];				if(white.r != 0xFF || white.g != 0xFF || white.b != 0xFF)			ROS_WARN("Inconsistent color, expect white, got RGB(%d, %d, %d)", white.r, white.g, white.b);				if(black.r != 0x00 || black.g != 0x00 || black.b != 0x00)			ROS_WARN("Inconsistent color, expect black, got RGB(%d, %d, %d)", black.r, black.g, black.b);				// Doesn't check gray because it is not needed		//if(gray.r != 0x7F || gray.g != 0x7F || gray.b != 0x7F)		//	ROS_WARN("Inconsistent color, expect gray, got RGB(%d, %d, %d)", gray.r, gray.g, gray.b);	}			void CleanUp()	{		ROS_DEBUG("Modulation module cleaning up...");		if(mask != nullptr)			SDL_FreeSurface(mask);	}	void LoadMaskMap(const std::string & path)	{		mask = SDL_LoadBMP(path.c_str());		if(!mask)		{			ROS_FATAL("Cannot load mask file %s, %s", path.c_str() ,SDL_GetError());			ros::shutdown();		}		isLoad = true;				//ROS_INFO("Load mask bitmap, format %s", SDL_GetPixelFormatName(mask->format->format));		MaskSanityCheck();		if(SDL_MUSTLOCK(mask))			ROS_WARN("Mask surface must be locked before accessing");			}		void CreateFrame(SDL_Surface * to, int delta = 5)	{				if(to->w != mask->w || to->h != mask->h)			ROS_ERROR("Inconsistent surface size : mask %dx%d window %dx%d", mask->w, mask->h, to->w, to->h);				if(SDL_MUSTLOCK(to))			SDL_LockSurface(to);		if(SDL_MUSTLOCK(mask))			SDL_LockSurface(mask);				cvt::BGR2CIELab((cvt::byte*)to->pixels, to->w * to->h * 4);				for(int index = 0; index < to->w * to->h; index++)		{			// masked byte			if(((cvt::byte*)(mask->pixels))[index] == 0x00)			{				int newL = ((cvt::byte*)(to->pixels))[index * 4] + delta;				newL = (newL > 255 ? 255 : newL);				((cvt::byte*)(to->pixels))[index * 4] = (newL < 0 ? 0 : newL);			}		}				cvt::CIELab2BGR((cvt::byte*)to->pixels, to->w * to->h * 4);				if(SDL_MUSTLOCK(mask))			SDL_LockSurface(mask);		if(SDL_MUSTLOCK(to))			SDL_UnlockSurface(to);	}}